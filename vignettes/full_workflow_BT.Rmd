---
title: "Full Workflow Bildungstrend"
author: "Edna Grewers"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Full Workflow Bildungstrend}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Intro

## Goal of the Vignette

This vignettes describes the full workflow of creating a codebook (or Skalenhandbuch) via the `eatCodebook` package. For illustrative purposes we use a small example data set which comes alongside the package and contains different types of variables (e.g., numeric, categorical, pooled variables, scales). We import the data set using the `eatGADS` package, which is automatically installed when `eatCodebook` is installed.

```{r eatcodebook setup}
library(eatCodebook)
file <- system.file("extdata", "example2_clean.sav", package = "eatCodebook")
dat <- eatGADS::import_spss(file)
```

The main function for creating a Skalenhandbuch or codebook is called `eatcodebook()`. It takes the input from several lists and data frames that you create throughout this vignette and converts them into one long object containing LaTeX code. You have to be mindful of special characters (like α and other Greek letters) in string input from the data frames as they might throw errors down the line. Also, formatting in Excel is lost in the LaTeX script, so you may need to add LaTeX code in the Excel files. The most common occurrences are mentioned in this vignette.

While working on the codebook, you will probably find some mismatches or errors in the data. You then have to recreate every data frame or Excel table you created so far, including the changes you made to those objects. This vignette contains examples how to write a script in R that you can just rerun in those cases, without having to redo a lot of work. 

## What is a Codebook?

In order to answer research questions, research institutes collect a lot of data. Usually the data isn't used to answer all possible questions, but just the ones of interest to the study they were collected for. When people want to to do their own research, they can ask the institutes for the data.  
A codebook contains **all of the collected variables** of a study or data collection, including their instructions, relevant statistics, references, and more. With that you can see, whether data sets might help you answer the question you do research on, before asking for the data. 


## About this Vignette

There are several chapters explaining how to create a codebook. You need at least two sets of data and additional information to add like the references or instructions of the variables, the order they're supposed to be displayed in the codebook and more. Each chapter contains an `About` section explaining the what and why of what you are doing and a `To-do` section explaining how to do these things in `R` step by step.

The package `eatCodebook` was created with the codebook for the [IQB Bildungstrends](https://www.iqb.hu-berlin.de/bt/) in mind. Some use cases are specific to these Bildungstrends (BT) studies, but you can create a codebook for your own study with this vignette, as well. 

The example code in this vignette will focus on the example data set available in the package `eatCodebook`. You can find example code that's more specific for the BT codebook in the template repository on GitHub. 


--------------------------------------------------------------------------------

# Setup

Before we start, we need to setup a proper work space. Creating a codebook takes a while and involves several files, so when you don't protocol your progress well, it's easy to lose focus. When editing the files in R, the script can get very long, so I recommend to use several .R documents to maintain an overview.

## create a new Repository

First set up a new private repository in the [`iqb-research` project](https://github.com/orgs/iqb-research/repositories) and use the template `SHB_Erstellung_Vorlage`. when you don't have access to this repository, ask the package developer for help or create your own repository. 


![](.\pictures\repo_template.png){width=70%}

You now have all the .R templates that you need, but you might have to create the issues yourself. The To-dos should be apparent from this vignette or you can copy the issues from the template repo by hand. You find the following files:

## File Structure

There are several files and folders. The .R files contain example scripts and to-dos, that you need to adjust and add to. 

| R File | Description |
|------------------------------------|------------------------------------|
| `0_main.R` | The main file you work in. You can work with just this file and ignore the others, if you want. I recommend using this file for smaller changes and the separate files for more complex changes. With this file, you can create Excel files which you then have to edit manually or in R. |
| `1_kennwerte.R` | Create and edit the `inputForDescriptives` files. This might not be needed, when you don't have to adjust anything here. |
| `2_varinfo.R` | Create and edit the `varinfo` file. This file contains the core content of the codebook. `eatCodebook()` creates the table structure with variable names and labels on its own, but you have to add structure, references, instructions, etc.. |
| `3_gliederung.R` | The information read from `varinfo` is usually incomplete, so you have to add missing section names. |
| `4_literatur.R` | Create and edit the `reference` file. You have to match the short references to the long ones. You also have to add proper latex syntax for italic text or URLs. |
| `5_latex_intro.R` | A template to create a .tex file with latex syntax out of a a Word .docx document. You need this later when creating the intro. |
| `6_Erstellung_kurz.R` | A short script which can create a new codebook version after you created all the necessary Excel files.|

You need to make sure, that there are three folders and create them if not. 

| Folder | Description |
|------------------------------------|------------------------------------|
| `excel_files` | Here you save all of the created Excel files to save the progress. |
| `Latex` | Here you save the .tex files and pdfs of the finished latex script for the codebook. You can add the folder `archive` to keep different versions to compare. |
| `Texte` | Here you can save the intro text or cover, etc. |

Pull the repo and start with the file `0_main.R`. You usually don't need to copy any code from this vignette, because the template already contains example code lines that you can copy or adjust.

## Packages

You need to make sure you have the latest package versions installed. The packages you need are usually at the top of the files in `setup`. To save time you can install them before you start your work.

```{r packages, eval=FALSE}
# main
remotes::install_github("beckerbenj/eatCodebook")
library(eatCodebook)
remotes::install_github("beckerbenj/eatGADS")
library(eatGADS)
# varinfo
remotes::install_github("weirichs/eatTools")
library(eatTools)
# references
install.packages("tidyxl")
library(tidyxl)
# latex_intro
install.packages("readtext")
library(readtext)
```

After you set up your work space, we will work through the templates or the To-dos step by step in this vignette. 

--------------------------------------------------------------------------------

# 1. Import Data

The first step is the data import. 

## About the Data

The BT studies usually have several SPSS data files (`.sav`) that you can import with `import_spss()`, but you can also import `.RDS` files with `readRDS()`. If you work with Github, the data sets are probably too large to upload to Github, so they would need to be stored locally. The BT codebook works with multiple data sets that are stored in a list. But the process should also work if you have only one data set. 

> [!NOTE]
> 
> The same variable name cannot be used more than once across the data sets. 

The data sets can be stored in `GADSdat` objects, containing two data frames: one for the variables and the actual data, the other contains the meta data or labels for the variables. 

### Order of the Data Sets

You have to save all the data sets in one list that also determines the order in which the variables are displayed in the codebook. It's best to choose the order you want it to have later right away, so you don't have to rerun the script later. 

> [!NOTE]
> In the past the BT data sets were ordered like this: 
>
> - **data_sus**: student questionnaire
> - **data_lfb_allg**: general teacher questionnaire
> - **data_lfb_spez**: learngroup specific teacher questionnaire
> - **data_slfb**: school administration questionnaire
> - **data_match**: data to match different data sets
> - **data_linking**: data to link different data sets
>
> But it's best to ask about the order to make sure.


## Data Import To-do

Open the file `0_main.R`. First you need to install and load the packages `eatCodebook` and `eatGADS`, if you haven't already done that.

### Import the Data

Either use `import_spss()` for .sav (SPSS) files or `readRDS()` to import each data set separately, you just need a string with your local file path. Name them in a meaningful manner. Here you have an example syntax, where you would need to add the proper **file name**.  

```{r data import, eval=FALSE}
data_sus      <- eatGADS::import_spss("Q:\\filepath\\Daten_sus.sav")
data_lfb_allg <- eatGADS::import_spss("Q:\\filepath\\Daten_lfb_allg.sav")
data_lfb_spez <- eatGADS::import_spss("Q:\\filepath\\Daten_lfb_spez.sav")
data_slfb     <- eatGADS::import_spss("Q:\\filepath\\Daten_slfb.sav")
```

### Save Data in a List

After importing the data, you need to save it in one list `datalist`. The order determines the order in which they are displayed in the codebook. The names should be consistent throughout. 

```{r datenliste, eval=FALSE}
datalist <- list(sus = data_sus,
                 lfb_allg = data_lfb_allg, lfb_spez = data_lfb_spez,
                 slfb = data_slfb)
```


--------------------------------------------------------------------------------

# 2. Descriptive Statistics

Now you have the raw data, but you want the descriptive statistics for the codebook, not the whole data sets. 

## About Descriptive Statistics

One of the key elements of a codebook are descriptive statistics shortly describing each variable in the data set. What kind of descriptive statistics is reported for each variable depends on the type of the variable. The function `createInputForDescriptives()` creates a template to provide the information that is needed to calculate the descriptive statistics for an `GADSdat` object. The function has some arguments you can use to get a better result and less manual editing in the next step.

### Input for Descriptives Table

Here you can see an example how the object should look like and what the different columns mean. 

```{r createInputForDescriptives}
inputForDescriptives <- createInputForDescriptives(GADSdat = dat)
head(inputForDescriptives)
```

You can look at the template data frame either in R or save it in a new Excel file.

```{r export descriptives, eval=FALSE}
# look at it in R
View(inputForDescriptives)

# export in Excel
writeExcel(inputForDescriptives, "file_path/inputForDescriptives.xlsx")
```

Some information may need to be modified because the function does not label it correctly. For this, it is necessary to understand the functionality and check the variable entries. We will come back to how to actually edit the table in R. 

> [!TIP]
> Here is a brief overview of the different columns in this object:
>
> - **varName**: The name of the variable of the GADS-object
> - **varLabel**: The label of the variable of the GADS-object
> - **format**: The format of the variable of the GADS-object, e.g. how to display the variable in the codebook
> - **imp**: Indicator if imputed variables are involved
> - **type**: Indicator of whether it is a single variable, a scale or a scale's item
> - **scale**: Indicator of how the variable is to be represented, e.g. what kind of statistics are shown
> - **group**: Possibility to group variables, e.g. to group scales and their items. 

In the **varName**, **varLabel** and **format** columns are information about the variables of the data set. You don't have to edit anything.

**imp** can be set to *WAHR* or *FALSCH*. If there are several variables to be displayed on one page, this column must be set to *WAHR* for these variables and they must be assigned to the same group at **group**. That is the case for imputed variables.

**type** can be set to *variable*, *scale* or *item*. If it is a scale consisting of several individual variables, the scale variable is set to *scale* and the individual items to *item*. All other variables should always get *variable* as an entry.

The **scale** column specifies how the variable is to be displayed. If it is empty, no descriptives are displayed. *nominal* variables display the frequency distribution of the labeled categories. *ordinal* variables display the frequency distribution of the labeled categories *and* the statistical parameters (like *M* or *SD*). *numeric* variables only display the statistical parameters, without labeld categories. 

Now follow the possibilities of how variables can be represented in the codebook and how the table must be edited for this.

### Variables without Descriptives

This can be the case, for example, with ID variables or character variables. The page would be displayed like this:  
<br>
<img src="./pictures/codebook_IDs.PNG" alt="codebook_IDs" />  
<br>  
The entry must look like this:  
<br>
<img src="./pictures/input_IDs.PNG" alt="input_IDs" />  
<br>  

### Categorial Variables

Variables with **nominal** scales should display only the frequency distribution of the labeled categories. The page would be displayed like this:   
<br>
<img src="./pictures/codebook_nominal.PNG" alt="codebook_nominal" />
<br>  

The example data set doesn't have any nominal variables at the moment. If your data set has nominal variables, you can create that page with the following input:  

<br>
<img src="./pictures/input_nominal.PNG" alt="input_nominal" />  
<br>  

### Categorial Variables and Statistical Parameters

Variables with **ordinal** scales should display the frequency distribution of the labeled categories as well as the statistical parameters *N* (number of participants), *M* (mean) and *SD* (standard deviation). The page would be displayed like this:  

<br>
<img src="./pictures/codebook_ordinal.PNG" alt="codebook_ordinal" />
<br>  

To create it, the Excel should be edited as follows:  
<br>
<img src="./pictures/input_ordinal.PNG" alt="input_ordinal" />  
<br>  

### Numeric Variables without Labeled Values

Variables with **numeric** scales should display only statistical parameters: *N* (number of participants), *M* (mean), *SD* (standard deviation), *Min.* (lowest value) and *Max.* (highest value). This can be used, for example, for variables that represent age or variables with values in the decimal range. Nevertheless, these variables can contain labels for values. If they are defined as missing, these values are not taken into account in the calculation but are still reported. The page would be displayed like this:  

<br>
<img src="./pictures/codebook_numeric.PNG" alt="codebook_numeric" />  
<br>  

To create an entry for a numeric variable without labeled values, the Excel must look like this:  
<br>
<img src="./pictures/input_numeric.PNG" alt="input_numeric" />  
<br>  

### Scale Variables with Individual Items

It is possible to get the following entries in the codebook for a **scale** and the items it is made of:  

<br>
<img src="./pictures/codebook_scale1.PNG" alt="codebook_scale1" /><img src="./pictures/codebook_scale2.PNG" alt="codebook_scale2" /><img src="./pictures/codebook_scale3.PNG" alt="codebook_scale3" />
<br>  

To get these pages the individual items must be labeled as **ordinal** and **item**, and the scale as **numeric** and **scale**. They must all have the same name at **group** so that they are displayed together.  
<br>  
<img src="./pictures/input_scale.PNG" alt="input_scale_new" />  
<br>  

This only works, when they are grouped and labeled correctly. Later the function `createScaleInfo()` creates a data frame with all scales and their items that were grouped like this. 

### Fake Scales

Sometimes several items make up a scale, but the data set doesn't have a matching scale-variable. The codebook would display it like a normal scale (see *Scale Variables with Individual Items*) with the same descriptive statistics. 

To display fake scales like a real one, you need to group them like a real scale, but in the **type** column you need to write **fake_item**, so it looks like this:  

<br>
<img src="./pictures/input_fakeScale.PNG" alt="input_fakeScale" />  
<br>  

The function `createScaleInfo()` should add these fake scales to the data frame as well. But without the scale variable the information which variables belong to that scale might be lost. The individual variables might need to be added manually. More on that later.  

### Imputation Variables

The BT sometimes uses imputations, for instance, in the student data set (sus). It's a way to deal with missing data on variables by replacing missing data with substituted values, usually several times. You can recognize the variables by the add-on `(imputiert)` in their label or `_pooled` in their group. These imputations represent one (averaged) variable, so they should be displayed as one. Depending on what was specified in **scale**, it results in the following pages in the codebook. `pv_pooled` is has *numeric* input, `pvkat_pooled` has *ordinal* input.  

<br>
<img src="./pictures/codebook_imp1.PNG" alt="codebook_imp1" /><img src="./pictures/codebook_imp2.PNG" alt="codebook_imp2" />  
<br>  

To display it like this the **imp** column becomes relevant. It must be set to *WAHR* for these variables. In addition, the variables also need a common name in **group** and, depending on whether they are to be represented categorically or numerically, the corresponding designation in **scale**, the scale should probably match the original variable.  
<br>
<img src="./pictures/input_imp.PNG" alt="input_imp" />  
<br>  

The function `createScaleInfo()` adds imputed variables like a scale to the data frame. Without the scale variable the information which variables belongs together might be lost. In this case, it might not be relevant, though, as these variables are not a scale. 


## Descriptives Statistics To-do

Now you open `1_kennwerte.R`. The editing of the descriptives can be a lot of code, especially if you have several data sets, so it's best to do this in a separate file. The packages `eatCodebook` and `eatGADS` need to be loaded. Then you copy the `Import Data` Code in this file, so you can work on it without needing to open `0_main.R` the next time you work on it. 

For each imported data set, you create a new object with `createInputForDescriptives()` containing input for the descriptive statistics about each variable like their *name*, *label*, *format*, *scale level* or which variables are *grouped* together. You edit them according to the [About section](#input-for-descriptives-table), check the input and then you calculate the actual descriptive statistics with `calculateDescriptives()`. 


### Create **Input for Descriptives**

You use the function `createInputForDescriptives()` to create a data frame for each data set separately and name them according to your data sets like `descriptives_sus` or `descriptives_lfb_allg`, etc. The function needs the `GADSdat` data set (e.g. `data_sus`) and returns a data frame. 

```{r create input for descriptives, eval=FALSE}
# example data
inputForDescriptives <- createInputForDescriptives(GADSdat = dat, nCatsForOrdinal = 4)

# BT example
descriptives_sus <- createInputForDescriptives(GADSdat = data_sus, nCatsForOrdinal = 4)
descriptives_lfb_allg <- createInputForDescriptives(GADSdat = data_lfb_allg, nCatsForOrdinal = 4)
```

You should save each data frame separately so save your progress. When you work with the template you don't need to adjust the file path - the Excel should be saved in the folder `excel_files`. You just need to make sure, that you are in the right working directory. Otherwise you would have to add the proper file path. Remember adjusting the file names when you copy and paste the code for the other data sets.

```{r saving descriptives, eval=FALSE}
# example data
writeExcel(inputForDescriptives, ".\\excel_files\\inputForDescriptives.xlsx")

# BT template examples
writeExcel(descriptives_sus, ".\\excel_files\\descriptives_sus.xlsx")
writeExcel(descriptives_lfb_allg, ".\\excel_files\\descriptives_lfb_allg.xlsx")
```

Now you should have as many Excel files as you imported data sets. 

### Check and Edit `inputForDescriptives`

After saving them as Excel files you need to import them again with `getInputForDescriptives()` to check whether the Excel has the right format. 

```{r import descriptives, eval=FALSE}
inputForDescriptives <- getInputForDescriptives(".\\excel_files\\inputForDescriptives.xlsx")

# BT template example
descriptives_sus <- getInputForDescriptives(".\\excel_files\\descriptives_sus.xlsx")
```

Then you can look at the descriptives either by opening Excel manually or by opening them in RStudio with `View()`. 

```{r look at descriptives, eval=FALSE}
View(inputForDescriptives)
# BT template example
View(descriptives_sus)
```

It should look somethings like this:

![](.\pictures\R_view(descriptives).png)

Now you have to check, whether everything is the way you need it to be. If not, you have to either make changes in the Excel file manually or directly in R. If you write a script that changes the data frame in R, you can easily rerun it if you need to recreate the descriptives later (which is often the case). After that you should save your changes under `descriptives_sus_edited.xlsx`, so you don't need to recreate the original Excel later if needed.

#### Edit `inputForDescriptives` in R

Sometimes `createInputForDescriptives` creates different scale levels or type labels than we need. You can adjust each line individually with `descriptives$scale` or `descriptives$type` and the row number `[n]`. Or you change multpile lines at the same time. 

The column **scale** is later important for how the variable is shown in the finished codebook. For example when variables get the scale `nominal`, when they should have `ordinal`. That is especially important for scale items. You can adjust that by extracting all relevant variables, for instance by name, using `grep`, to identify the position of all variables that start with a certain name in `descriptives_sus`. Sometimes you need to recreate the descriptives objects/files and the position might change, but the variable name usually stays the same. In this case you wouldn't have to adjust your code and can just rerun it. With the position of the  variables, you can change multiple variables at the same time. You can also change other columns this way. 

```{r editing descriptives scale, eval=FALSE}
# extracting the position of variables skala1_item1 - skala1_item3
pos <- grep("skala1_", inputForDescriptives$varName)
# adjusting the input for the column `scale`
inputForDescriptives$scale[pos] <- "ordinal"
```

```{r editing descriptives group, eval=FALSE}
# adjusting the input for the column `group`
inputForDescriptives$group[pos] <- "skala1"
```

Scales and their items should be labeled correctly in the column **type**. The scale needs the label `scale`, the items the label `item`; variables from a fake scale have no scale and need the label `fake_item`. If not you can identify scale variables with the first line of code. The scale's `varName` is usually also the `group` label. In the second step you can identify all variables with matching `group` labels that have the wrong `type` label. 

```{r editing descriptives type, eval=FALSE}
# identifying all scale variables
group <- inputForDescriptives[inputForDescriptives$type == "scale",]$group
# adjusting the item variables
for(var in group){
  inputForDescriptives[inputForDescriptives$group == var & inputForDescriptives$type == "variable",]$type <- "item" 
}
```

### Save you changes

When you made sure, the variables are correctly labeled and grouped, you save the new data frame in Excel. You can either overwrite the existing Excel file, but I recommend saving it in a new `_edited.xlsx` file for better comparison. You use the same lines as before, just change the file name. Then import the new Excel again to make sure the format is still right and load it into a new object with the ending `_edited`. 

```{r saving edited descriptives, eval=FALSE}
# save changes
writeExcel(inputForDescriptives, ".\\excel_files\\inputForDescriptives_edited.xlsx")
# import changes
inputForDescriptives_edited <- getInputForDescriptives(".\\excel_files\\inputForDescriptives_edited.xlsx")
```


### Check Scale Consistency

Not all data sets have scales, but for the ones that do, you should use `checkScaleConsistency()`. The function checks whether the grouping of variables that belong to the same scale matches in both the data set itself and the created descriptive file. Be mindful of warnings or errors, they might indicate something that will cause problems later. 

```{r check scale, eval=FALSE}
check_scale <- checkScaleConsistency(dat, inputForDescriptives_edited, 1:nrow(inputForDescriptives_edited))

# BT template example
check_scale_sus <- checkScaleConsistency(data_sus, descriptives_sus_edited, 1:nrow(descriptives_sus_edited))
```


### Calculate Descriptives

After preparing and checking the *input for descriptives* you now actually *calculate the descriptives* (`kennwerte`) with `calculateDescriptives()` for each data set separately. Depending on how large the data set is, this can take a while. 

```{r calculate descriptives, eval=FALSE}
kennwerte_example <- calculateDescriptives(GADSdat = dat, inputForDescriptives = inputForDescriptives_edited, showCallOnly = FALSE)

# BT template examples
kennwerte_sus <- calculateDescriptives(GADSdat = data_sus, inputForDescriptives = descriptives_sus_edited, showCallOnly = FALSE)
kennwerte_lfb_allg <- calculateDescriptives(GADSdat = data_lfb_allg, inputForDescriptives = descriptives_lfb_allg_edited, showCallOnly = FALSE)
```


### Save Objects in Two Lists

After creating the `inputForDescriptives` and the calculating the descriptives (kennwerte), you save all of them in **two lists**, one for the *input*, one for the *kennwerte*. The order should match the order of `datalist`, the list of the raw data sets; the names should also match the `datalist` names. 

```{r inputForDescriptices and kennwerte lists, eval=FALSE}
# inputForDescriptives list
input_descriptives <- list(sus = descriptives_sus_edited,
                           lfb_allg = descriptives_lfb_allg_edited,
                           lfb_spez = descriptives_lfb_spez_edited,
                           slfb = descriptives_slfb_edited)
# kennwerte list
kennwerte <- list(sus = kennwerte_sus,
                  lfb_allg = kennwerte_lfb_allg, lfb_spez = kennwerte_lfb_spez,
                  slfb = kennwerte_slfb)
```

Then save them in two `.RDS` files with `saveRDS()`. You can import them again with `readRDS()`. 

```{r save inputForDescriptices and kennwerte, eval=FALSE}
# save files
saveRDS(input_descriptives, ".\\excel_files\\input_descriptives.RDS")
saveRDS(kennwerte, ".\\excel_files\\kennwerte.RDS")
# load files
input_descriptives <- readRDS(".\\excel_files\\input_descriptives.RDS")
kennwerte <- readRDS(".\\excel_files\\kennwerte.RDS")
```

You should add the last two lines (load files) in you `0_main.R` script behind the data import. 


------------------------------------------------------------------------

# 3. Value and Missing Labels

Another imported part of a codebook is the documentation of the value labels of valid and missing values. A respective overview is created via `createMissings()`.

## About Missings

You need to save the created data frame in Excel and read it in again with `getMissings()` to clean up and check the input. Otherwise you usually don't need to edit anything here. 

### Example Table

Here you can see how the missings data frame should look like. 

```{r missings example}
missings <- createMissings(dat, inputForDescriptives = inputForDescriptives)
head(missings)
```

## Missings To-do

For this you need to open `0_main.R` again. You create a new data frame with `createMissings()`; you need the data sets (`datalist`) and the input for descriptives (`input_descriptives`) for that. Then you save it in an Excel file `missings.xlsx` and import it again with `getMisings()` to check the format. 

```{r create missings, eval=FALSE}
# create missings
missings <- createMissings(datalist, input_descriptives)
# save as an Excel file
writeExcel(df_list = missings, row.names = FALSE, filePath = ".\\excel_files\\missings.xlsx")
# import Excel file and check for right format
missings <- getMissings(".\\excel_files\\missings.xlsx")
```


------------------------------------------------------------------------

# 4. Scales

In order to display scales correctly, you need an Excel files with an overview over all the scales and their items. 

## About Scales

Scale variables contain information about their scale, e.g. the items that make up the scale. Fake scales contain of variables, but don't have a separate scale variable; you can still display them as scales, though (see Descriptive Statistics: Fake Scales).  

### Example Table

This is what the scale info should look like: 

```{r create scaleInfo}
scaleInfo <- createScaleInfo(inputForDescriptives)
head(scaleInfo)
```


## Scales To-do

Open `0_main.R` and scroll down the `scales`. You need to create one `skalen.xlsx` Excel file for all the data sets combined. It contains the info which variables are scales and which items belong to it. You just need the list `input_descriptives` for that. Usually you don't need to edit this file. 

### Create Scales

The function `createScaleInfo()` reads the information about scales out of the descriptives list, and creates a new data frame that you need to save as an Excel file. 

```{r scales, eval=FALSE}
# creating the object
scales <- createScaleInfo(input_descriptives)
# save as an Excel file
writeExcel(df_list = scales, row.names = FALSE, filePath = ".\\excel_files\\scales.xlsx")
```

You need to look at the file to make sure all scales are displayed correctly, for instance with `View(scales)`. It looks for grouped variables, so not every scale might be in here and not every variable in the file might be a scale. All errors and mismatches occurring here can or should usually be fixed in the `inputForDescriptive` files. 

you should also import the file again with `getScaleInfo()` which also checks for errors and cleans up the format.

```{r get scales, eval=FALSE}
# read in Excel file and check for right format
scales <- getScaleInfo(".\\excel_files\\skalen.xlsx")
```


------------------------------------------------------------------------

# 5. Abbreviation List

The codebook's intro and additional texts might have abbreviations that need explaining. You can add an abbreviation list in the appendix for that. You need a list of two data frames (or Excel file) with the abbreviations and the explanations. You don't need this object for the minimal version of the codebook, so you can skip this part or come back to it later. 

## About the Abbreviation List

You can usually copy the Excel `abbr_list.xlsx` or `abkürzungen.xlsx` from last BTs and adjust them if needed or you create you own file with `createAbbrList()`. 

### Example Tables

When you use `createAbbrList()` it creates a list of two data frames **Akronyme** (acronyms) and **statistische Formelzeichen** (statistical formula) with two columns each. The first should contain all abbreviations used in any text in the codebook and their meaning. The second should contain all statistical formula symbols and their meaning. It should look something like this:

```{r example abbr_list, eval=FALSE}
View(abbr_list)
```

![](.\pictures\abbr_list_R.png)

In Excel: First sheet `Akronyme`, second sheet `statistische Formelzeichen`

![](.\pictures\abbr_list_akronym.png)

![](.\pictures\abbr_list_statFormula.png)

> [!CAUTION]
> Be mindful of using LaTeX syntax when you want to display special characters or italic letters!  


## Abbreviation List To-do

Open `0_main.R` and scroll down the `abbreviation list`. You create either an empty object for the abbreviation list with `createAbbrList()` or read in the one from last year's BT and call it `abbr_list`, and save it in a new Excel file.

### Create New Empty List

You create two empty data frames in a list, already labeled correctly. You can edit it in R or save it to Excel as `abkürzung.xlsx` and edit it manually. 

```{r create abbr_list, eval=FALSE}
abbr_list <- createAbbrList()
# save in Excel
writeExcel(df_list = abbr_list, row.names = FALSE, filePath = ".\\excel_files\\abkürzung.xlsx")
```

### Import Old List

You can also import an old `abkürzung.xlsx` from the last BT, for instance, save it to your work space and update it if necessary. You would need to update your `file path` for that. 

```{r import abbr_list, eval=FALSE}
abbr_list <- getExcel("Q:\\filepath\\abkuerzung.xlsx")
# save in Excel
writeExcel(df_list = abbr_list, row.names = FALSE, filePath = ".\\excel_files\\abkürzung.xlsx")
```

### Update the List

You can add or delete entries in R like with any other data frame that is saved in a list.

```{r edit abbr_list, eval=FALSE}
# add a new line
abbr_list$`Statistische Formelzeichen`[nrow(abbr_list$`Statistische Formelzeichen`) + 1,] = c("α", "Cronbachs Alpha")
# add multiple lines
newLines <- data.frame(Abkuerzung = c("AG", "ALLG"), Bedeutung = c("Arbeitsgemeinschaft", "Allgemeine Schule"))
abbr_list$Akronyme <- rbind(abbr_list$Akronyme, newLines)
# remove lines
abbr_list$Akronyme <- abbr_list$Akronyme[-2,]
```

### Notes on Special Letters

LaTeX can't display Greek characters when you just use the letter by itself. You might need to adjust the spelling. `$\alpha$` is LaTeX code and should be printed like the image shows.

```{r edit abbr_list alpha, eval=FALSE}
# edit one entry
abbr_list$`Statistische Formelzeichen`$Symbol[1] <- "$\alpha$"
```

![](.\pictures\abbr_list_alpha.png)

Italic letters or subscript/superscript also need special LaTeX code. The code `$_{pw}$` makes the *pw* in subscript. Use `$^{2}$` for supercript the 2 or `\textit{M}` to print italic text or letters.

```{r edit abbr_list subscipt, eval=FALSE}
# new line with correct syntax
abbr_list$`Statistische Formelzeichen`[nrow(abbr_list$`Statistische Formelzeichen`) + 1,] = c("r$_{pw}$", "Part-whole-korrigierte Korrelation")
```

Either add new lines already with the LaTeX syntax or edit existing entries. 

### Use `makeAbbrList()`

When the Excel file from past BTs has commentary/extra columns in it, you can't use the function `makeAbbrList()`. To make sure you only the have two columns per sheet/data frame, you can save just the first two columns per sheet in your `abbr_list` object. After that you need to save the changes to Excel.

```{r makeAbbrList setup, eval=FALSE}
# edit abbr_list
abbr_list$Akronyme <- abbr_list21$Akronyme[,1:2]
abbr_list$`Statistische Formelzeichen` <- abbr_list21$`Statistische Formelzeichen`[,1:2]
# save in Excel
writeExcel(df_list = abbr_list, row.names = FALSE, filePath = ".\\excel_files\\abkürzung.xlsx")
```

When you have all the abbreviations, you can create the LaTeX code that you need directly from the Excel file.

```{r makeAbbrList, eval=FALSE}
# creates LaTeX syntax
abbr_list <- makeAbbrList(".\\excel_files\\abkuerzung.xlsx")
```


------------------------------------------------------------------------

# 6. Variable Information (varinfo)

Creating and editing the `varinfo.xlsx` file/object is the **main work** of creating the codebook. This objects contains all information about the variables, their order and structure, as well as their references, instructions, remarks or information about the background model. There is only one object/Excel file overall, but each data set has its own sheet or data frame, so you can edit them separately.

## About Varinfo

After preparing the `inputForDescriptives` you use the two lists `datalist` (containing the data sets) and `input_descriptives` to create a template list of data frames, with one data frame per data set. Each data frame consists of a column for the variables in the order of the `inputForDescriptives_edited` file and several columns with additional information about each variable. 

In order for the variables to be displayed correctly in the codebook, you need to add information on layout, structure, subsection names, references, instructions, etc. for each variable. The order of the variables in `varinfo` determines the order of the variables in the codebook. 

### Example Table

Here is in example what that can look like.

```{r varinfo example}
varinfo <- createVarInfo(dat, inputForDescriptives = inputForDescriptives)
head(varinfo)
```

Now we will look at the function of each column below. 

> [!TIP]
> Here is a brief overview of the different columns in *varinfo*:
>
> - **Var.Name**: The name of the variable
> - **in.DS.und.SH**: Indicator whether the variable is in the codebook and data set
> - **Unterteilung.im.Skalenhandbuch**: Overview of subsection names
> - **Layout**: Assignment of the layout options
> - **LabelSH**: The label of the variable (has to match the data set)
> - **Anmerkung.Var**: Assignment of annotations in the codebook
> - **Gliederung**: Overview of section numbering
> - **Reihenfolge**: Order of variables in the codebook
> - **Titel**: Title of the codebook page of the variable
> - **rekodiert**: Display whether a variable was previously recoded
> - **QuelleSH**: Specification of the sources of the variable in a questionnaire
> - **Instruktionen**: Specification of the instructions of the variable in a questionnaire
> - **Hintergrundmodell**: Indication of whether the variable is in the background model
> - **HGM.Reihenfolge**: the order for the background model (in the appendix)
> - **HGM.Variable.erstellt.aus**: Indication for the background model from which variables the variable was created
> - **intern.extern**: Indication of whether the variable is for internal or external use
> - **Seitenumbruch.im.Inhaltsverzeichnis**: Indication whether there is a pagination in the table of contents for the title

#### Var.Name

Each variable name has to be unique across data sets. You can't have a variable in data set 2 called `IDBL` if there's an `IDBL` in data set 1 already.

You can't have duplicated subsection names, either. For instance, in the chapters `Unterricht in Mathematik` and `Unterricht in Deutsch` you can't have the subsection `Selbstkonzept` in both, they would need to be called something like `Selbstkonzept Mathematik` and `Selbstkonzept Deutsch`. 

> [!CAUTION]
> Across data sets, variables can't have the same name!  
> Across chapters, subsections can't have the same name!

You don't need to edit the variable names. 

#### in.DS.und.SH

`DS` means *data set*, `SH` *Skalenhandbuch* (meaning codebook). Possible entries are `DS`, `SH`, `ja` and `nein`. 

The **in.DS.und.SH** column indicates whether a variable only appears in the data set but does not get its own page (*ds*), whether it appears both in the codebook and in the data set (*ja*), whether it only appears in the codebook (*sh*) or neither (*nein*). 

> [!NOTE]
> When to assign what label:
>
> - **ds**: for example, for the items of the **scale variables**, as they do not receive their own pages
> - **sh**: for **pooled variables**, as they are shown in the codebook but do not exist in the actual data set
> - **nein**: for variables that are added independently; This can be the case, if you want to include them in the BGM information, but the variables do not exist in the data set
> - **ja**: all other variables or scale items

When everything is labeled correctly in the `inputForDescriptives` files, the right labels should be assigned. But you might need to adjust them by hand. 

#### Unterteilung.im.Skalenhandbuch and Gliederung

The **Unterteilung.im.Skalenhandbuch** (subsections in the codebook) column gives the name for the subsections. 

In the **Gliederung** (structure) column, the section numbers must be inserted. Subsections such as "1.1", "1.2",... "2.1". The names of the corresponding chapters is done in a later function (s. 7. structure). The names of the subsections and the corresponding numbers must always be identical for the variables.  

You need to add the `Gliederung` as well as the `Unterteilung.im.Skalenhandbuch` from another (Excel) file, for the BT codebook it's usually called something like `finale Reihenfolge.xlsx`. See *To-do* on how to do that. 

#### Layout

The input for the **Layout** column is automatically created after using `inferLayout()`, see *To-do* on how to do that. 

#### LabelSH and Titel

The **Titel** column specifies the title for the page and defaults to the variable label. `LabelSH` has to be identical to the label in the data set, usually without special characters or umlauts. The spelling of `Titel` can be adjusted and umlauts are OK. 

If you have an Excel file, for instance, with all variables and their labels and titles, you can copy that into `varinfo` without having to check the spelling for each variable's title. 

#### Anmerkung.Var

In this column, comments can be inserted (special text highlighting or breaks must be in the LaTeX syntax), which are displayed as annotations on the respective codebook page.  

#### Reihenfolge

In the **Reihenfolge** (order) column, the order of the variables for the codebook can be specified. However, the order of the subsections already determines the order of the variables. If the column is left empty, the order in the table corresponds to the order in the codebook.

For the BT codebook, this column is usually left empty. 

#### rekodiert

If a variable has been **recoded** in the course of previous editing, this can be marked with a `ja` in the `rekodiert` column and the variable gets a corresponding note in the codebook as inverted if it is an item of a scale. 

You recognize these variables by the addition `_r` in their name. 

#### QuelleSH and Instruktionen

In **QuelleSH** (sources), the short version of a reference can be specified. Based on this, there is a later function that creates the bibliography and in which one can specify the long version of the reference. All references should be in [APA](https://apastyle.apa.org/style-grammar-guidelines/references/examples) format.

In the **Instruktionen** (instructions) column, you can use a LaTeX code to indicate which instruction was used to collect the variable in a questionnaire.

Each variable can have a reference and/or instruction. You can find them in the same Excel file for the BT codebook. See *To-do* on how to add this information.
 
#### Background Model (HGM)

With `eatCodebook` you can also create a page in the appendix for a background model (BGM) or *Hintergrundmodell* (HGM) in German. [ergänzen, was ein HGM ist bzw. warum man das macht].

It should look like this: `Hintergrundvariable` contains the variable, `Erstellt aus` the variable(s) the (new) variable was created from (if any), and `Inhalt der Hintergrundvariable` contains the variable's label, e.g. the content of the background variable. 

<img src="./pictures/BGM.PNG" alt="BGM" />   

There are three columns in `varinfo` that you need to edit for variables to show up in the appendix. 

> [!TIP]
>
> - **Hintergrundmodell**: Indication of whether the variable is in the background model.
> - **HGM.Reihenfolge**: the order for the background model (in the appendix)
> - **HGM.Variable.erstellt.aus**: Indication for the background model from which variables the variable was created

There should be another Excel file containing information on the background model, also on `Q:`. It should contain the variables that should show up in the appendix (`Variablenname`), their labels (`Variablenlabel`) and from which variables they were created from (`basevar`). 

For the variable to appear in the appendix, the column `Hintergrundmodell` must be set to *ja*. Otherwise, there must be a *nein*. Then you add the variables they were created from (if any), for instance listed in `basevar`. They should show up in the order they are displayed in the codebook. 

## Varinfo To-do

Now comes the harder part of actually creating and editing the `varinfo`. You can either create and save a `varinfo.xlsx` file in `0_main.R` or you open `2_varinfo.R` and create `varinfo.xlsx` here. There's a lot to add,  While working on the `varinfo` you often need to recreate it multiple times, so I recommend writing a script in the additional file `2_varinfo.R` to do the editing. Then you can just rerun it without having to do too much. You should check after each recreation, whether the script still worked correctly, though.

When working on the BT codebook for IQB, you can find most Excel files containing the additional information to add on the network server *Q: FDZ und Bildungstrend*. 

When you open `2_varinfo.R` you will have to import the data and the descriptives in order to create `varinfo`. After the setup you need to add the following information. The order in which you add them is up to you, but it makes sense to keep to the order in this vignette. 

| Column in Varinfo | Where to get the Information from | Order |
|------------------------|------------------------|------------------------|
| `QuelleSH` and `Instruktionen` | Both usually in the same file under `Q:/filepath/04_Instruktionen_Quellen`, one Excel file per data set | tbd |
| `Gliederung` and `Unterteilung.im.Skalenhandbuch` | Often in one file called `Reihenfolge_Variable_final.xlsx` or similar, contains one sheet per data set | different from data sets |
| `rekodiert` | Info in the variable name: all with `_r` at the end | no order |
| `Hintergrundmodell`, `HGM.Reihenfolge` and `HGM.Variable.erstellt.aus` | in an extra Excel file, you probably have to ask about it | no order |
| optional: `Anmerkung.Var` | in an file on Q: | check order |

The order of the variables in `varinfo` depends on the order from the data sets. However, the final order of the variables might be different. The files for `Quellen` (refernces) and `Gliederung` (structure) usually contain all variables, whereas for the backgroundmodel/HGM or `rekodiert` you have to change the input for individual variables, so the order is not relevant.

I recommend starting with the files that have the same order as the original `varinfo`, so you only have to change the variable order once. For this vignette I'll just describe the procedure for one data set, but you need to do it for each data set or varinfo data frame/Excel sheet. 


### Varinfo Setup

#### Create Varinfo

Open `2_varinfo.R`. You first create a varinfo object with `createVarInfo()` from the SPSS data list you read in at the beginning (`datenliste`) and from the input for descriptives list you created out of that (`input_descriptives`): 

```{r create varinfo, eval=FALSE}
varinfo <- createVarInfo(datalist, input_descriptives)
```

If you have multiple data sets stored in `datalist`, the object `varinfo` will also be a list with several data frames. Each data frame contains all variables from a data set and columns that you need, but you still need to add a lot of information from other files. It's important that the data sets and descriptives were named the same (`sus`, `lfb_allg`, etc.), because `createVarInfo()` takes those names to name the different data frames. You can look at `varinfo` as a list or at each data frame separately:

```{r varinfo example list, eval=FALSE}
# View varinfo list object
View(varinfo)
# View data frames in varinfo
View(varinfo$sus)
View(varinfo$lfb_allg)
View(varinfo$lfb_spez)
View(varinfo$slfb)
```

This is what the list of data frames `varinfo` can look like: 

![](pictures\varinfo_object.png)

You can either save it directly as an Excel file or do the layout first. 

#### Infer Layout

You add layout information for each variable with `inferLayout()`. You need the newly created `varinfo` object and the `datalist` and `input_descriptives`. 

```{r infer layout varinfo, eval=FALSE}
varinfo <- inferLayout(varinfo, datalist, input_descriptives)
```

#### save to Excel

Now save to Excel `varinfo.xlsx` as a template, and `varinfo_edited.xlsx` as the file you actually work with. Then you import `varinfo_edited.xlsx` and check the format with `getVarInfo`.

```{r save varinfo, eval=FALSE}
# save to Excel
writeExcel(df_list = varinfo, row.names = FALSE, filePath = ".\\excel_files\\varinfo.xlsx")
writeExcel(df_list = varinfo, row.names = FALSE, filePath = ".\\excel_files\\varinfo_edited.xlsx")
# import and check format
varinfo <- getVarInfo(".\\excel_files\\varinfo_edited.xlsx")
```

### Add References and Instructions

To Add the references and instructions you need access to the an Excel file with all the variables listed plus their source/reference in APA short form (like `Hertel et al. (2014)`) and their instructions (in the questionnaire). The Excel should have two sheets, one with at least 4 columns (Variable, Label, Instruktion and Quelle), and a second one with the APA long from references that we need later. You need to do the following steps: 

> - import the references/instructions, select proper sheet (usually Sheet 1)
> - check the columns with `View()`: `Variable`, `Quelle` and `Instruktionen`
> - match the references and instructions to the order of varinfo
> - transfer the entries, check your progress/proper matching and save in between.

Linking or matching data sets are usually created due to technical reasons and usually don't have references or instructions, so you don't need to add anything to them. 

#### import references and instructions from Excel

Import the Excel file with `getExcel()`, you need to add the proper file path. Then select the right sheet, usually `sheet 1`, and look at the data frame. 

```{r import references, eval=FALSE}
quellen_sus <- getExcel("filepath\\Instruktionen_Quellen.xlsx")
quellen_sus <- quellen_sus$`Sheet 1`
View(quellen_sus)
```

The data frame should look something like this. 

![](pictures\varinfo_quellen.png){width=100%}

#### Check Variables

First, we should check, whether the two data frames `varinfo$sus` and `quellen_sus` contain the same variables with `setdiff()`. When the output is `character(0)` for both lines the names match. The first line might return a variable name that's in `varinfo$sus`, but not in `quellen_sus`, the second line the other way around. In either case you probably have to clean up the data frames first, before doing the next steps. 

```{r varinfo ref setdiff, eval=FALSE}
setdiff(varinfo$sus$Var.Name, quellen_sus$Variable)
setdiff(quellen_sus$Variable, varinfo$sus$Var.Name)
```

#### Clean Up Data

Before you clean up any data, it's best to ask your supervisor or the BT team on how to deal with these mismatches. In the following you will see a few possible reasons and how you can deal with them. 

The first line of `setdiff()` *`setdiff(varinfo$sus$Var.Name, quellen_sus$Variable)`* returns variables in `varinfo$sus` that are *not* in `quellen_sus`. These variables often were created due to technical or methodological reasons and usually have no references or instructions. You can ignore them at this point. 

The second line of `setdiff()` *`setdiff(quellen_sus$Variable, varinfo$sus$Var.Name)`* returns variables in `quellen_sus` that are *not* in `varinfo$sus`. That is the case when 1) variables changed spelling for some reason or 2) the variables are not supposed to be in this data frame, for instance, because they're already in another one (this might be the case for identifier variables). 

For 1) you adapt the spelling to match the spelling in `varinfo`. If this is the case, the first line usually also returns a variable with similar spelling. In the BT21 there is a variable called `Fach` in the `lfb_spez` data set, which was called `LFACH` in the `quellen` Excel. You can just rename it by identifying where it is and adjusting the spelling. This is a case where it might be easier to update the Excel file, but you could also do this in your script:

```{r varinfo ref spelling, eval=FALSE}
quellen_lfb_spez$Variable[quellen_lfb_spez$Variable == "LFACH"] <- "Fach"
```

For 2) you might have to remove the rows of the data frame, so you can transfer them later more easily. For that you can save the respective variables from `setdiff()` in a character vector and run the loop below that identifies their entry in `quellen_sus` and removes them. For the BT21 three variables had to be removed, if there's only one that needs to be removed, you can skip the the loop.

```{r varinfo ref remove rows, eval=FALSE}
# identify position of variable "IDBL"
mismatch <- c("IDSCH", "IDBL", "LVERSION")
for(var in mismatch){
  # identify position of the variables in `mismatch` 
  pos <- grep(var, quellen_lfb_spez$Variable)
  # remove line
  quellen_lfb_spez <- quellen_lfb_spez[-pos,]
}
```

After that you check again for mismatches between the data frames. When there are none, you can go to the next step. Output from the first line can still be ignored. 

```{r varinfo ref setdiff 2, eval=FALSE}
setdiff(varinfo$sus$Var.Name, quellen_sus$Variable)
setdiff(quellen_sus$Variable, varinfo$sus$Var.Name)
```

#### Check Matching Variables

Not every variable will have a reference or instructions, some of them have the input `NA`, so in theory you could copy paste the columns to `varinfo`. However, the order of the variables between `varinfo` and the reference/instruction sheet might be different. To check the order you need the function `match()` which compares two character vectors - for instance `quellen_sus$Variable` and `varinfo$sus$Var.Name` which both contain the variable's names. 

```{r varinfo reference match var, eval=FALSE}
pos <- match(quellen_sus$Variable, varinfo$sus$Var.Name)
pos
```

It returns a numerical vector that contains the strings (here the names) of the second vector (`varinfo$sus$Var.Name`) in the order in which they appear in the first vector (`quellen_sus$Variable`). Strings in the second vector (varinfo) that don't appear in the first (`quellen_sus`) just won't show up, so any extra variables in `varinfo` will be ignored by this function. If there's a string in the first vector (quellen_sus) that isn't in the second (`varinfo`), the output will be `NA` - that shouldn't be the case, if you cleaned up the data properly.

#### Transfer References and Instructions

After making sure you have the right variables in your `quellen` object, you transfer the references and instructions from into `varinfo`. In `pos` you should now have the variable's order (as a numeric vector) of the variable names from `varinfo$sus` as they appear in `quellen_sus`. So when you write these two lines to your console, the references and instructions should be matched to the proper variable in `varinfo`. 

```{r varinfo ref in varinfo, eval=FALSE}
varinfo$sus$QuelleSH[pos] <- quellen_sus$Quelle
varinfo$sus$Instruktionen[pos] <- quellen_sus$Instruktion
```

#### Check New Input

It's best to compare the two data frames once more to make sure the references and instructions are matched with the respective variable. You can check all variables with `View()` or a random set of variables and look at the respective columns.  

```{r varinfo ref check, eval=FALSE}
# compares variables 1 to 10:
quellen_sus[1:10, c(1, 3, 4)]
varinfo$sus[1:10, c(1, 11:12)]
```

#### Save Progress

When everything matched correctly, save your progress and import the Excel with `getVarInfo()`.

```{r varinfo ref save, eval=FALSE}
writeExcel(df_list = varinfo, row.names = FALSE, filePath = ".\\07_SH_Erstellung\\varinfo_edited.xlsx")
varinfo <- getVarInfo(".\\07_SH_Erstellung\\varinfo_edited.xlsx")
```


### Add Structure and Subsections

For the BT, you can usually find the info on the *Gliederung* (subsection numbers, also referred to as *structure*) and *Unterteilung im Skalenhandbuch* (subsection names) in a Excel called something like `finale Reihenfolge` on Q:. It contains the variable names, their labels and subsection info (number and name), as well as adjusted titles (if needed), each of the data sets have their own sheet, except linking or matching data who still need subsection info (see *Linking and Matching Data*). This Excel file also contains the final order in which the variables should be displayed in the codebook, so you need to adjust the order in `varinfo` to match the one in `finale Reihenfolge` (final order). You need to do the following steps: 

> - import the `finale Reihenfolge` file, select proper sheet for your data set
> - delete unnecessary rows (sections)
> - add missing subsection
> - change order of `varinfo` to match the final order
> - separate subsection names and numbers
> - transfer subsection info in `varinfo`
> - update titles if necessary

> ![NOTE]
> 
> Each subsection name has to be unique. 

#### Import `finale Reihenfolge`

First you need to import the Excel file and select the proper sheet for your data set (`lfb_allg` for example). The column `Abschnitt` contains the subsection numbers and names, that need to be separated later.

```{r varinfo subsection import, eval=FALSE}
subsections <- getExcel("Q:\\BT2021\\BT\\90_Skalenhandbuch\\Reihenfolge_Variablen_final.xlsx")
subsections_lfb_allg <- subsections$LFB_allg
View(subsections_lfb_allg)
```

It might look like this: 

![](pictures\varinfo_subsections.png){width=100%}

`Abschnitt` starts with the section name *1 Testdesign* then with the first subsection name *1.1 identifikationsvariable* and then `NA`, then the next subsections *1.2 Testgruppenmerkmale* and *1.3 Rotation*, then the next section *2 Persönliche Angaben* and so forth. We need to clean up the table so we can match the correct subsection info to each variable in `varinfo`. 

#### Remove NAs in `varName`

We need the section names that start with a single digit like *1* later (see 7. structure). The `finale Reihenfolge` Excel added rows between sections, so you have some `NA` entries in the column `varName`, as well. To match the input for the subsections to `varinfo` we need to delete those rows for now. 

```{r varinfo subsection delete sections, eval=FALSE}
subsections_lfb_allg <- subsections_lfb_allg[!is.na(subsections_lfb_allg$varName),]
```

#### Seperate Subsection Names and Numbers

We need the number of the subsection and their names separate, so we can 1) check for duplicates and 2) transfer them in the respective `varinfo` columns. The package `eatTools` has a practical function for that: `halveString()`, which separates any string at a specified separator into two strings. After each number there's a blank space, so that's our separator. First we save our `Abschnitt` column in a new vector, then we separate numbers from names and save them in `sep`. It returns a data frame with two columns, that we can name *subsec number* and *subsec name*. 

```{r varinfo subsection separate, eval=FALSE}
sep <- subsections_lfb_allg$Abschnitt
sep <- eatTools::halveString(sep, " ", colnames = c("subsec number", "subsec name"))
```

Then we can add these two new columns to the existing data frame with `cbind()` and check whether it worked with `View()`. 

```{r varinfo subsection add new cols, eval=FALSE}
subsections_lfb_allg <- cbind(subsections_lfb_allg, sep)
View(subsections_lfb_allg)
```

It should look something like this now:

![](pictures\varinfo_subsections_sep.png){width=100%}

#### Check for Duplicates

For some BTs the same data collected for different subjects, so they have the same subsection names. Due to technical reasons each subsection name *has to be unique* in the codebook. So it's important to check for duplicates and report back, if you find any. Be mindful of `NA`s, as they are also seen as duplicated input. 

Now that we have the subsection names by themselves, we can check for duplicates in the column `subsec name`. `anyDuplicated()` checks if there are any duplicates, at all. If the output is `0`, there are no duplicates and you can go the next step. If the output is any other number, it indicates the position of the first duplicated entry in the column. `duplicated()` returns a logical vector of all entries, `TRUE` indicates duplicated entries.  

```{r varinfo subsection duplicates, eval=FALSE}
anyDuplicated(subsections_lfb_allg$`subsec name`[!is.na(subsections_lfb_allg$`subsec name`)])
duplicated(subsections_lfb_allg$`subsec name`[!is.na(subsections_lfb_allg$`subsec name`)])
```

#### Add Missing Subsections

Now we need to fill the `NA`s with the proper subsection info, which is always the one above. The `NA`s in row 3 needs to say *1.1* and *Identifikationsvariable*, in row 8 it should say *2.1* and *Soziodemografie*, etc. 

This loop checks every entry in the new columns `subsec number` and `subsec name` for `NA`s, if it finds one it fills it with the input from the entry before. After the loop you should check the columns with `View()`: for `NA`s, if the numbers are in order and match their names.

```{r varinfo subsection add subsections, eval=FALSE}
for(i in 1:nrow(subsections_lfb_allg)){
  if (is.na(subsections_lfb_allg$`subsec number`[i])){
    subsections_lfb_allg[, 5:6][i,] <- subsections_lfb_allg[, 5:6][i-1,]
  }
}
View(subsections_lfb_allg)
```






#### Change Varinfo Order






#### Add structure and subsection names in varinfo

#### Linking and Matching Data

#### adjust titles if necessary



#### Save Progress

When everything matched correctly, save your progress and import the Excel with `getVarInfo()`.

```{r varinfo structure save, eval=FALSE}
writeExcel(df_list = varinfo, row.names = FALSE, filePath = ".\\07_SH_Erstellung\\varinfo_edited.xlsx")
varinfo <- getVarInfo(".\\07_SH_Erstellung\\varinfo_edited.xlsx")
```


### Add Recoded Info


### Add Background Model Info


### Add Remarks



------------------------------------------------------------------------

# 7. Structure

## About the Structure

## Strucutre To-do

### Create Structure Table

### Add missing section names


------------------------------------------------------------------------

# 8. References

## About References

One Excel per data set with long format and short format linked to the item/variable.

> [!NOTE]
> References need to be in APA7 format. 

## References To-do

### Create `litInfo`

### Adjust Short References

No add-ons, no duplicates

### Import Formatting of Long References

### Adjust Long References

### Match Long and Short References

### Add Intro References

### Check for Duplicates


------------------------------------------------------------------------

# 9. Background Model

## About HGM?

Info about how it should looks like in the appendix?

## HGM To-do

that one line.

------------------------------------------------------------------------

# 10. Cover

## About the Cover

## Cover To-do

### convert to pdf

### Add Line


------------------------------------------------------------------------

# 11. Meta Data

## About Meta Data

> [!Note]
> something meta data
>
> -   authors
> -   Title

## Meta Data To-do

### Create Table

### Update Table



------------------------------------------------------------------------

# 12. Chapters

## About Chapters

Use Chapter names from last BTs.

## Chapters To-do

### Create Chapters

### Edit Chapters

------------------------------------------------------------------------

# 13. Other Texts: Intro

## About Intro

you prob. get a word file that needs to be converted into latex syntax. 

The Intro contains References as well, bla bla bla

## Intro To-do

*see maybe Vignette (tbd) about how to convert word.docx files into latex.tex files with R.*

### Convert Text into Latex Syntax

Use the template for that. 

### Save as .tex File




------------------------------------------------------------------------

# 14. Create the Codebook

## About the Codebook

### Minimal Version

### Add-ons

#### References

#### Cover

#### Intro

### Versions

> [!Note]
> while working on the Codebook, you will create different versions. it's best not to delete them, but save them in an `archive` folder to compare different version to one another if needed. 

## Codebook To-do in R

### Create the Codebook and Meta Data

### Save in Folder `Latex`

## Codebook To-do in TeXworks

### open .tex file

### render to pdf (twice)

### Dealing with Errors

#### Update Latex Packages

#### Special Characters



